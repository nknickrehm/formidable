<template lang="pug">
  .container
    modal(
      :class='showRemoveModal ? "is-active" : ""',
      :info='removeWarning',
      @accept='remove()',
      @reject='showRemoveModal = false',
      @close='showRemoveModal = false')
    modal(
      :class='showPDFModal ? "is-active" : ""',
      :info='pdfWarning',
      @accept='generatePDF()',
      @reject='showPDFModal = false',
      @close='showPDFModal = false')
    .navbar
      .navbar-item
        router-link.button.is-medium#btnBack(
          :to='{ name: "Dashboard" }')
          span.icon.is-small
            i.fa.fa-arrow-left
          span(
            v-html='$t("dashboard")')

    .section
      .buttons
          a.button(
            @click='showPDFModal = true',
            :disabled='isgeneratingPDF',
            :class='isgeneratingPDF ? "is-loading" : ""')
            span.icon
              i.fa.fa-download
            span(
              v-html='$t("exportPDF")')

          router-link.button.is-warning(
            :to='{ name: "EditForm", params: { _id, isNew: false } }')
            span.icon
              i.fa.fa-edit
            span(
              v-html='$t("edit")')

          a.button.is-danger(
            @click='showRemoveModal = true')
            span.icon
              i.fa.fa-trash
            span(
              v-html='$t("delete")')

      .buttons
        label.button(v-for='tag in tags',
          :class='tag.name === currentTag ? tag.colorClass : "is-outlined"',
          @click='setTag(tag.name)')
            span.icon.is-small(
              v-if='tag.name === currentTag')
              i.fa.fa-tag
            input.radio(type='radio',
              name='tagGroup')
            label(
              v-html='$t(tag.name)')

      .container(
        v-if='form')
        .box
          .content
            p(
              v-html='$t("type") + ": " + $t(form.type)')
            p(
              v-for='field in fields',
              v-if='shouldShow(field.condition)',
              v-html='$t(field.name + "_label") + ": " + getValue(field)',
              :class='field.isValid ? "" : "has-text-danger"')
</template>

<script>
import Modal from '@/components/UIComponents/Modal';
import API from '@/api';
import helpers from '@/helpers';

export default {
  name: 'FormSummary',
  data() {
    return {
      form: null,
      fields: [],
      h: helpers,
      isgeneratingPDF: false,
      tags: [
        {
          name: 'draft',
          colorClass: 'is-warning',
        },
        {
          name: 'sent',
          colorClass: 'is-info',
        },
        {
          name: 'accepted',
          colorClass: 'is-success',
        },
        {
          name: 'rejected',
          colorClass: 'is-danger',
        },
      ],
      currentTag: '',
      showRemoveModal: false,
      showPDFModal: false,
      removeWarning: {
        key: 'removeWarning',
        de: 'Wollen Sie diesen Antrag wirklich löschen?',
        en: 'Do you really want to delete this form?',
      },
      pdfWarning: {
        key: 'pdfWarning',
        de: 'Die anschließend generierte PDF-Datei ist unter Umständen unvollständig. In diser Ansicht rot markierte Felder wurden als fehlerhaft erkannt und werden somit nicht in das PDF-Formular übertragen. <br><br>Jegliche Nutzung der generierten Formulare außerhalb dieser Evaluation erfolgt auf eigene Gafahr! Möchten Sie dennoch fortfahren?',
        en: 'The PDF file that will be generated might be incomplete. Data marked red in this view might to be invalid and will not be transfered into the PDF form. <br><br>All usage of PDF files generated by this application are at your own risk. Proceed anyway?',
      },
    };
  },
  props: ['_id'],
  components: { Modal },
  created() {
    API.getFormById(this._id).then((form) => {
      this.form = form;
      this.fields = form.fields;

      const englishStrings = {};
      const germanStrings = {};

      this.fields.forEach((field) => {
        englishStrings[`${field.name}_label`] = field.label.en;
        germanStrings[`${field.name}_label`] = field.label.de;
        if (field.type === 'multiSelect') {
          field.options.forEach((option) => {
            englishStrings[`${field.name}_${option.name}_label`] = option.label.en;
            germanStrings[`${field.name}_${option.name}_label`] = option.label.de;
          });
        }
      });

      this.$i18n.add('en', englishStrings);
      this.$i18n.add('de', germanStrings);

      this.currentTag = form.tag;
    });
  },
  methods: {
    formatDate(sDate) {
      if (!sDate) return '–';
      const date = this.h.makeDate(sDate);

      return this.$t('date', {
        year: date.getFullYear(),
        day: date.getDate(),
        month: this.$t(`m${date.getMonth() + 1}`),
      });
    },
    getValue(field) {
      switch (field.type) {
        case 'textField': return field.value || '';
        // eslint-disable-next-line
        case 'datePicker': return field.isValid ? this.formatDate(field.value) : (field.value ? field.value : '–');
        case 'radioGroup': return this.$t(field.value) || '';
        case 'multiSelect': return field.options.filter(option => option.value || false)
          .map(option => this.$t(`${field.name}_${option.name}_label`))
          .join(', ') || '';
        case 'buttonSelect': return this.$t(field.value) || '';
        default: return '???';
      }
    },
    shouldShow(conditions) {
      if (typeof conditions === 'boolean') return conditions;

      let show = true;

      conditions.forEach((condition) => {
        this.fields.forEach((field) => {
          if (field.type === 'multiSelect') {
            field.options.forEach((option) => {
              if (option.name === condition.field) {
                if (option.value !== condition.value) show = false;
              }
            });
          } else if (field.name === condition.field) {
            if (field.value !== condition.value) show = false;
          }
        });
      });
      return show;
    },
    remove() {
      API.removeFormById(this._id)
        .then(() => setTimeout(() => this.$router.push({ name: 'Dashboard' }, 200)));
    },
    setTag(newTag) {
      API.changeTagForForm(this._id, newTag)
        .then(() => { this.currentTag = newTag; });
    },
    generatePDF() {
      this.showPDFModal = false;
      this.isgeneratingPDF = true;
      API.generatePDF(this._id)
        .then((blob) => {
          const data = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = data;
          document.body.appendChild(link);
          link.click();
          setTimeout(() => {
            // For Firefox it is necessary to delay revoking the ObjectURL
            window.URL.revokeObjectURL(data);
          }, 100);
          this.isgeneratingPDF = false;
        });
    },
  },
};
</script>

<style lang="stylus" scoped>
</style>
